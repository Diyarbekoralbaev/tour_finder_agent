import os
import requests
import json
import re
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional, Union
from dotenv import load_dotenv
from langchain_core.tools import tool
from difflib import get_close_matches

load_dotenv()

TURTOPAR_API_BASE = "https://api.turtopar.uz/api/v1"

# Cache for locations to avoid repeated API calls
_locations_cache = None
_origin_locations_cache = None

# Transliteration mapping for common location names
TRANSLITERATION_MAP = {
    # === UZBEKISTAN (Origin Cities) ===
    'toshkent': '—Ç–∞—à–∫–µ–Ω—Ç',
    'tashkent': '—Ç–∞—à–∫–µ–Ω—Ç',
    'samarqand': '—Å–∞–º–∞—Ä–∫–∞–Ω–¥',
    'samarkand': '—Å–∞–º–∞—Ä–∫–∞–Ω–¥',
    'buxoro': '–±—É—Ö–∞—Ä–∞',
    'bukhara': '–±—É—Ö–∞—Ä–∞',
    'xiva': '—Ö–∏–≤–∞',
    'khiva': '—Ö–∏–≤–∞',
    'namangan': '–Ω–∞–º–∞–Ω–≥–∞–Ω',
    "farg'ona": '—Ñ–µ—Ä–≥–∞–Ω–∞',
    'fergana': '—Ñ–µ—Ä–≥ana',
    'fargona': '—Ñ–µ—Ä–≥–∞–Ω–∞',

    # === COUNTRIES ===
    # Turkey
    'turkiya': '—Ç—É—Ä—Ü–∏—è',
    'turkey': '—Ç—É—Ä—Ü–∏—è',
    'turtsiya': '—Ç—É—Ä—Ü–∏—è',

    # Uzbekistan
    "o'zbekiston": '—É–∑–±–µ–∫–∏—Å—Ç–∞–Ω',
    'ozbekiston': '—É–∑–±–µ–∫–∏—Å—Ç–∞–Ω',
    'uzbekistan': '—É–∑–±–µ–∫–∏—Å—Ç–∞–Ω',

    # France
    'fransiya': '—Ñ—Ä–∞–Ω—Ü–∏—è',
    'france': '—Ñ—Ä–∞–Ω—Ü–∏—è',

    # UAE
    'baa': '–æ–∞—ç',
    'uae': '–æ–∞—ç',
    'emirates': '–æ–∞—ç',

    # Egypt
    'misr': '–µ–≥–∏–ø–µ—Ç',
    'egypt': '–µ–≥–∏–ø–µ—Ç',

    # Thailand
    'tailand': '—Ç–∞–∏–ª–∞–Ω–¥',
    'thailand': '—Ç–∞–∏–ª–∞–Ω–¥',

    # Malaysia
    'malayziya': '–º–∞–ª–∞–π–∑–∏—è',
    'malaysia': '–º–∞–ª–∞–π–∑–∏—è',

    # Indonesia
    'indoneziya': '–∏–Ω–¥–æ–Ω–µ–∑–∏—è',
    'indonesia': '–∏–Ω–¥–æ–Ω–µ–∑–∏—è',

    # Maldives
    'maldiv orollari': '–º–∞–ª—å–¥–∏–≤—ã',
    'maldiv': '–º–∞–ª—å–¥–∏–≤—ã',
    'maldives': '–º–∞–ª—å–¥–∏–≤—ã',
    'maldivy': '–º–∞–ª—å–¥–∏–≤—ã',

    # India
    'hindiston': '–∏–Ω–¥–∏—è',
    'india': '–∏–Ω–¥–∏—è',

    # Singapore
    'singapur': '—Å–∏–Ω–≥–∞–ø—É—Ä',
    'singapore': '—Å–∏–Ω–≥–∞–ø—É—Ä',

    # China
    'xitoy': '–∫–∏—Ç–∞–π',
    'china': '–∫–∏—Ç–∞–π',
    'kitay': '–∫–∏—Ç–∞–π',

    # Georgia
    'gruziya': '–≥—Ä—É–∑–∏—è',
    'georgia': '–≥—Ä—É–∑–∏—è',

    # Vietnam
    'vetnam': '–≤—å–µ—Ç–Ω–∞–º',
    'vietnam': '–≤—å–µ—Ç–Ω–∞–º',

    # Azerbaijan
    'ozarbayjon': '–∞–∑–µ—Ä–±–∞–π–¥–∂–∞–Ω',
    'azerbayjan': '–∞–∑–µ—Ä–±–∞–π–¥–∂–∞–Ω',
    'azerbaijan': '–∞–∑–µ—Ä–±–∞–π–¥–∂–∞–Ω',

    # Qatar
    'qatar': '–∫–∞—Ç–∞—Ä',
    'katar': '–∫–∞—Ç–∞—Ä',

    # Oman
    'ummon sultonligi': '–æ–º–∞–Ω',
    'ummon': '–æ–º–∞–Ω',
    'oman': '–æ–º–∞–Ω',

    # Sri Lanka
    'shri lanka': '—à—Ä–∏-–ª–∞–Ω–∫–∞',
    'sri lanka': '—à—Ä–∏-–ª–∞–Ω–∫–∞',

    # Kazakhstan
    "qozog'iston": '–∫–∞–∑–∞—Ö—Å—Ç–∞–Ω',
    'qozogiston': '–∫–∞–∑–∞—Ö—Å—Ç–∞–Ω',
    'kazakhstan': '–∫–∞–∑–∞—Ö—Å—Ç–∞–Ω',

    # Saudi Arabia
    'saudiya arabistoni': '—Å–∞—É–¥–æ–≤—Å–∫–∞—è –∞—Ä–∞–≤–∏—è',
    'saudiya': '—Å–∞—É–¥–æ–≤—Å–∫–∞—è –∞—Ä–∞–≤–∏—è',
    'saudi arabia': '—Å–∞—É–¥–æ–≤—Å–∫–∞—è –∞—Ä–∞–≤–∏—è',

    # Japan
    'yaponiya': '—è–ø–æ–Ω–∏—è',
    'japan': '—è–ø–æ–Ω–∏—è',

    # === CITY MAPPINGS ===
    # Turkey cities
    'istanbul': '—Å—Ç–∞–º–±—É–ª',
    'marmaris': '–º–∞—Ä–º–∞—Ä–∏—Å',
    'kappadokiya': '–∫–∞–ø–ø–∞–¥–æ–∫–∏—è',
    'cappadocia': '–∫–∞–ø–ø–∞–¥–æ–∫–∏—è',
    'antaliya': '–∞–Ω—Ç–∞–ª—å—è',
    'antalya': '–∞–Ω—Ç–∞–ª—å—è',
    'bodrum': '–±–æ–¥—Ä—É–º',
    'bursa': '–±—É—Ä—Å–∞',
    'dalaman': '–¥–∞–ª–∞–º–∞–Ω',
    'anqara': '–∞–Ω–∫–∞—Ä–∞',
    'ankara': '–∞–Ω–∫–∞—Ä–∞',
    "sovg'a": '–±–µ–ª–µ–∫',
    'belek': '–±–µ–ª–µ–∫',
    'side': '—Å–∏–¥–µ',
    'izmir': '–∏–∑–º–∏—Ä',
    'kushadasi': '–∫—É—à–∞–¥–∞—Å—ã',
    'trabzon': '—Ç—Ä–∞–±–∑–æ–Ω',
    'kemer': '–∫–µ–º–µ—Ä',
    'alanya': '–∞–ª–∞–Ω—å—è',
    'fethiye': '—Ñ–µ—Ç—Ö–∏–µ',

    # UAE cities
    'dubay': '–¥—É–±–∞–π',
    'dubai': '–¥—É–±–∞–π',
    'abu-dabi': '–∞–±—É-–¥–∞–±–∏',
    'abu dhabi': '–∞–±—É-–¥–∞–±–∏',
    'sharja': '—à–∞—Ä–¥–∂–∞',
    'sharjah': '—à–∞—Ä–¥–∂–∞',
    'ras-al-xayma': '—Ä–∞—Å-—ç–ª—å-—Ö–∞–π–º–∞',
    'ras al khaimah': '—Ä–∞—Å-—ç–ª—å-—Ö–∞–π–º–∞',
    'fujeyra': '—Ñ—É–¥–∂–µ–π—Ä–∞',
    'fujairah': '—Ñ—É–¥–∂–µ–π—Ä–∞',

    # Thailand cities
    'pxuket': '–ø—Ö—É–∫–µ—Ç',
    'phuket': '–ø—Ö—É–∫–µ—Ç',
    'bangkok': '–±–∞–Ω–≥–∫–æ–∫',
    'pattaya': '–ø–∞—Ç—Ç–∞–π—è',

    # Egypt cities
    'sharm al-shayx': '—à–∞—Ä–º-—ç–ª—å-—à–µ–π—Ö',
    'sharm el sheikh': '—à–∞—Ä–º-—ç–ª—å-—à–µ–π—Ö',
    'hurghada': '—Ö—É—Ä–≥–∞–¥–∞',

    # Malaysia cities
    'kuala-lumpur': '–∫—É–∞–ª–∞-–ª—É–º–ø—É—Ä',
    'kuala lumpur': '–∫—É–∞–ª–∞-–ª—É–º–ø—É—Ä',
    'penang': '–ø–µ–Ω–∞–Ω–≥',
    'langkawi': '–ª–∞–Ω–≥–∫–∞–≤–∏',

    # Indonesia cities
    'bali': '–±–∞–ª–∏',
    'jakarta': '–¥–∂–∞–∫–∞—Ä—Ç–∞',
    'denpasar': '–¥–µ–Ω–ø–∞—Å–∞—Ä',

    # Maldives cities
    'male': '–º–∞–ª–µ',
    'bodufoludo': '–±–æ–¥–∞—Ñ–æ–ª—É–¥—É',
    'feridu': '—Ñ–µ—Ä–∏–¥—É',
    'todu': '—Ç–æ–¥–¥—É',

    # India cities
    'goa': '–≥–æ–∞',
    'dehli': '–¥–µ–ª–∏',
    'delhi': '–¥–µ–ª–∏',
    'mumbay': '–º—É–º–±–∞–∏',
    'mumbai': '–º—É–º–±–∞–∏',

    # China cities
    'pekin': '–ø–µ–∫–∏–Ω',
    'beijing': '–ø–µ–∫–∏–Ω',
    'shanxay': '—à–∞–Ω—Ö–∞–π',
    'shanghai': '—à–∞–Ω—Ö–∞–π',
    'guanchjou': '–≥—É–∞–Ω—á–∂–æ—É',
    'guangzhou': '–≥—É–∞–Ω—á–∂–æ—É',
    'xaynan': '—Ö–∞–π–Ω–∞–Ω—å',
    'hainan': '—Ö–∞–π–Ω–∞–Ω—å',
    'sanya': '—Å–∞–Ω—å—è',

    # Vietnam cities
    'fukuok': '—Ñ—É–∫—É–æ–∫',
    'phu quoc': '—Ñ—É–∫—É–æ–∫',
    'nyachang': '–Ω—è—á–∞–Ω–≥',
    'nha trang': '–Ω—è—á–∞–Ω–≥',
    'nha-trang': '–Ω—è—á–∞–Ω–≥',
    'danang': '–¥–∞–Ω–∞–Ω–≥',
    'hoi an': '—Ö–æ–π–∞–Ω',
    'kamran': '–∫–∞–º—Ä–∞–Ω—å',

    # Azerbaijan cities
    'baku': '–±–∞–∫—É',
    'naftalan': '–Ω–∞—Ñ—Ç–∞–ª–∞–Ω',
    'lenkoran': '–ª–µ–Ω–∫–æ—Ä–∞–Ω—å',

    # Georgia cities
    'tbilisi': '—Ç–±–∏–ª–∏—Å–∏',
    'borjomi': '–±–æ—Ä–∂–æ–º–∏',

    # Other cities
    'doha': '–¥–æ—Ö–∞',
    'maskat': '–º–∞—Å–∫–∞—Ç',
    'muscat': '–º–∞—Å–∫–∞—Ç',
    'salala': '—Å–∞–ª–∞–ª–∞',
    'salalah': '—Å–∞–ª–∞–ª–∞',
    'tokio': '—Ç–æ–∫–∏–æ',
    'tokyo': '—Ç–æ–∫–∏–æ',
    'parij': '–ø–∞—Ä–∏–∂',
    'paris': '–ø–∞—Ä–∏–∂',
}


def normalize_and_transliterate(name: str) -> List[str]:
    """Normalize and provide transliteration variants for location name"""
    normalized = name.lower().strip()
    variants = [normalized]

    # Add transliterated version if available
    if normalized in TRANSLITERATION_MAP:
        variants.append(TRANSLITERATION_MAP[normalized])

    # Add reverse transliterations (Cyrillic -> Latin)
    reverse_map = {v: k for k, v in TRANSLITERATION_MAP.items()}
    if normalized in reverse_map:
        variants.append(reverse_map[normalized])

    return list(set(variants))  # Remove duplicates


def get_locations_data():
    """Get and cache all location data"""
    global _locations_cache
    if _locations_cache is None:
        try:
            response = requests.get(f"{TURTOPAR_API_BASE}/locations?with_child=1", timeout=10)
            if response.status_code == 200:
                data = response.json()
                if data.get('success'):
                    _locations_cache = data.get('data', [])
                    with open("locations_cache.json", "w", encoding="utf-8") as f:
                        json.dump(_locations_cache, f, ensure_ascii=False, indent=2)
        except Exception as e:
            print(f"Error fetching locations: {e}")
            _locations_cache = []
    return _locations_cache or []


def get_origin_locations_data():
    """Get and cache origin location data"""
    global _origin_locations_cache
    if _origin_locations_cache is None:
        try:
            response = requests.get(f"{TURTOPAR_API_BASE}/locations/origin-locations", timeout=10)
            if response.status_code == 200:
                data = response.json()
                if data.get('success'):
                    _origin_locations_cache = data.get('data', [])
        except Exception as e:
            print(f"Error fetching origin locations: {e}")
            _origin_locations_cache = []
    return _origin_locations_cache or []


def find_location_comprehensive(location_name: str, location_type: str = "destination") -> Dict[str, Any]:
    """
    Comprehensive location finder that returns both exact matches and suggestions
    """
    locations = get_origin_locations_data() if location_type == "origin" else get_locations_data()

    if not locations:
        return {
            "exact_match": None,
            "country_match": None,
            "city_matches": [],
            "suggestions": []
        }

    search_variants = normalize_and_transliterate(location_name)
    print(f"üîç Comprehensive search for {location_type}: '{location_name}'")
    print(f"   Search variants: {search_variants}")

    exact_match = None
    country_match = None
    city_matches = []
    all_countries = []
    all_cities = []

    if location_type == "destination":
        # Build comprehensive lists
        for country in locations:
            country_variants = normalize_and_transliterate(country["name"])
            country_info = {
                "id": country["id"],
                "name": country["name"],
                "variants": country_variants,
                "type": "country",
                "data": country,
                "cities": []
            }

            # Check for country match
            for search_variant in search_variants:
                for country_variant in country_variants:
                    if search_variant == country_variant:
                        country_match = country_info
                        exact_match = country_info
                    elif search_variant in country_variant or country_variant in search_variant:
                        if not country_match:
                            country_match = country_info

            # Process cities in this country
            for city in country.get("children", []):
                city_variants = normalize_and_transliterate(city["name"])
                city_info = {
                    "id": city["id"],
                    "name": city["name"],
                    "variants": city_variants,
                    "type": "city",
                    "data": city,
                    "country": country["name"],
                    "country_id": country["id"]
                }

                # Check for city match
                for search_variant in search_variants:
                    for city_variant in city_variants:
                        if search_variant == city_variant:
                            exact_match = city_info
                            city_matches.append(city_info)
                        elif search_variant in city_variant or city_variant in search_variant:
                            city_matches.append(city_info)

                all_cities.append(city_info)
                country_info["cities"].append(city_info)

            all_countries.append(country_info)

    else:  # origin locations
        for city in locations:
            city_variants = normalize_and_transliterate(city["name"])
            city_info = {
                "id": city["id"],
                "name": city["name"],
                "variants": city_variants,
                "type": "city",
                "data": city
            }

            for search_variant in search_variants:
                for city_variant in city_variants:
                    if search_variant == city_variant:
                        exact_match = city_info
                    elif search_variant in city_variant or city_variant in search_variant:
                        city_matches.append(city_info)

            all_cities.append(city_info)

    # Remove duplicates from city matches
    unique_city_matches = []
    seen_ids = set()
    for city in city_matches:
        if city["id"] not in seen_ids:
            unique_city_matches.append(city)
            seen_ids.add(city["id"])

    return {
        "exact_match": exact_match,
        "country_match": country_match,
        "city_matches": unique_city_matches,
        "all_countries": all_countries if location_type == "destination" else [],
        "all_cities": all_cities
    }


def search_tours_for_location(location_id: int, **search_params) -> Dict[str, Any]:
    """Search tours for a specific location ID"""
    try:
        params = {"destination_location_child_id": location_id}
        params.update(search_params)

        response = requests.get(f"{TURTOPAR_API_BASE}/tours", params=params, timeout=15)

        if response.status_code == 200:
            data = response.json()
            if data.get("success"):
                tours = data.get("data", [])
                return {
                    "success": True,
                    "tours": tours,
                    "count": len(tours)
                }

        return {"success": False, "tours": [], "count": 0}
    except Exception as e:
        print(f"Error searching tours for location {location_id}: {e}")
        return {"success": False, "tours": [], "count": 0}


@tool
def search_tours(
        origin_city: Optional[str] = None,
        destination_place: Optional[str] = None,
        departure_date: Optional[str] = None,
        budget_max: Optional[int] = None,
        duration_days: Optional[int] = None,
        sort_by: str = "price_asc"
) -> Dict[str, Any]:
    """
    Intelligent tour search with hierarchical fallbacks.
    Searches for tours by destination with smart fallbacks.
    """
    try:
        search_params = {}

        # Handle origin city
        if origin_city:
            origin_result = find_location_comprehensive(origin_city, "origin")
            if origin_result["exact_match"]:
                search_params["origin_location_child_id"] = origin_result["exact_match"]["id"]
                print(f"‚úÖ Found origin: {origin_result['exact_match']['name']}")

        # Add other parameters
        if departure_date:
            search_params["origin_date"] = departure_date
        if sort_by:
            search_params["sort"] = sort_by

        # Handle destination search with intelligent fallbacks
        if destination_place:
            location_result = find_location_comprehensive(destination_place, "destination")

            # Strategy 1: Try exact match first
            tours_found = []
            search_strategy = "none"
            searched_location = None

            if location_result["exact_match"]:
                exact_match = location_result["exact_match"]
                tours_result = search_tours_for_location(exact_match["id"], **search_params)

                if tours_result["success"] and tours_result["count"] > 0:
                    tours_found = tours_result["tours"]
                    search_strategy = f"exact_match_{exact_match['type']}"
                    searched_location = exact_match
                    print(f"‚úÖ Found {len(tours_found)} tours for exact match: {exact_match['name']}")

            # Strategy 2: If no tours found and we matched a city, try the country
            if not tours_found and location_result["exact_match"] and location_result["exact_match"]["type"] == "city":
                country_id = location_result["exact_match"].get("country_id")
                if country_id:
                    tours_result = search_tours_for_location(country_id, **search_params)
                    if tours_result["success"] and tours_result["count"] > 0:
                        tours_found = tours_result["tours"]
                        search_strategy = "country_fallback"
                        # Find country info
                        for country in location_result["all_countries"]:
                            if country["id"] == country_id:
                                searched_location = country
                                break
                        print(f"‚úÖ Found {len(tours_found)} tours in country fallback")

            # Strategy 3: If we matched a country but no tours, try its cities
            if not tours_found and location_result["country_match"]:
                country = location_result["country_match"]
                all_country_tours = []
                cities_with_tours = []

                for city in country["cities"]:
                    city_tours_result = search_tours_for_location(city["id"], **search_params)
                    if city_tours_result["success"] and city_tours_result["count"] > 0:
                        all_country_tours.extend(city_tours_result["tours"])
                        cities_with_tours.append(city["name"])

                if all_country_tours:
                    tours_found = all_country_tours
                    search_strategy = "cities_in_country"
                    searched_location = country
                    print(f"‚úÖ Found {len(tours_found)} tours across cities in {country['name']}")

            # Strategy 4: Try city matches if nothing else worked
            if not tours_found and location_result["city_matches"]:
                for city in location_result["city_matches"][:3]:  # Try top 3 matches
                    city_tours_result = search_tours_for_location(city["id"], **search_params)
                    if city_tours_result["success"] and city_tours_result["count"] > 0:
                        tours_found = city_tours_result["tours"]
                        search_strategy = "similar_city"
                        searched_location = city
                        print(f"‚úÖ Found {len(tours_found)} tours for similar city: {city['name']}")
                        break

            # Apply additional filters
            if tours_found:
                filtered_tours = tours_found

                if budget_max:
                    original_count = len(filtered_tours)
                    filtered_tours = [t for t in filtered_tours
                                      if t.get("price") is not None and t.get("price", 0) <= budget_max]
                    print(f"üí∞ Budget filter: {original_count} -> {len(filtered_tours)} tours")

                if duration_days:
                    original_count = len(filtered_tours)
                    filtered_tours = [t for t in filtered_tours
                                      if t.get("days") is not None and abs(t.get("days", 0) - duration_days) <= 2]
                    print(f"üìÖ Duration filter: {original_count} -> {len(filtered_tours)} tours")

                # Build suggestions for alternative locations
                suggestions = []
                if search_strategy == "country_fallback":
                    # Suggest specific cities in the country
                    country = searched_location
                    cities_with_tours = []
                    for city in country["cities"]:
                        city_tours_result = search_tours_for_location(city["id"], **search_params)
                        if city_tours_result["success"] and city_tours_result["count"] > 0:
                            cities_with_tours.append(city["name"])
                    suggestions = cities_with_tours[:5]

                return {
                    "status": "success",
                    "count": len(filtered_tours),
                    "tours": filtered_tours[:10],
                    "search_strategy": search_strategy,
                    "searched_location": searched_location["name"] if searched_location else None,
                    "searched_location_type": searched_location["type"] if searched_location else None,
                    "suggestions": suggestions,
                    "has_more": len(filtered_tours) > 10,
                    "message": _build_search_message(search_strategy, searched_location, len(filtered_tours),
                                                          destination_place)
                }
            else:
                # No tours found - provide helpful suggestions
                suggestions = []
                if location_result["country_match"]:
                    # Suggest cities in the matched country
                    suggestions = [city["name"] for city in location_result["country_match"]["cities"][:5]]
                elif location_result["city_matches"]:
                    # Suggest similar cities
                    suggestions = [city["name"] for city in location_result["city_matches"][:5]]
                else:
                    # Suggest popular destinations
                    popular_countries = ["Turkiya", "BAA", "Tailand", "Misr", "Gruziya"]
                    suggestions = popular_countries

                return {
                    "status": "no_tours_found",
                    "count": 0,
                    "tours": [],
                    "searched_for": destination_place,
                    "suggestions": suggestions,
                    "message": f"No tours found for '{destination_place}'. Try these destinations: {', '.join(suggestions)}"
                }

        else:
            # No destination specified, search all
            response = requests.get(f"{TURTOPAR_API_BASE}/tours", params=search_params, timeout=15)
            if response.status_code == 200:
                data = response.json()
                if data.get("success"):
                    tours = data.get("data", [])
                    return {
                        "status": "success",
                        "count": len(tours),
                        "tours": tours[:10],
                        "message": f"Found {len(tours)} tours available"
                    }

        return {
            "status": "error",
            "message": "Failed to search tours",
            "tours": [],
            "count": 0
        }

    except Exception as e:
        print(f"üí• Search error: {str(e)}")
        return {
            "status": "error",
            "message": f"Search error: {str(e)}",
            "tours": [],
            "count": 0
        }


@tool
def search_tours(
        origin_city: Optional[str] = None,
        destination_place: Optional[str] = None,
        departure_date: Optional[str] = None,
        budget_max: Optional[int] = None,
        duration_days: Optional[int] = None,
        sort_by: str = "price_asc"
) -> Dict[str, Any]:
    """
    Intelligent tour search with hierarchical fallbacks.
    Searches for tours by destination with smart fallbacks.
    """
    try:
        search_params = {}

        # Handle origin city
        if origin_city:
            origin_result = find_location_comprehensive(origin_city, "origin")
            if origin_result["exact_match"]:
                search_params["origin_location_child_id"] = origin_result["exact_match"]["id"]
                print(f"‚úÖ Found origin: {origin_result['exact_match']['name']}")

        # Add other parameters
        if departure_date:
            search_params["origin_date"] = departure_date
        if sort_by:
            search_params["sort"] = sort_by

        # Handle destination search with intelligent fallbacks
        if destination_place:
            location_result = find_location_comprehensive(destination_place, "destination")

            # Strategy 1: Try exact match first (city or country)
            tours_found = []
            search_strategy = "none"
            searched_location = None
            original_location = None

            if location_result["exact_match"]:
                exact_match = location_result["exact_match"]
                original_location = exact_match
                tours_result = search_tours_for_location(exact_match["id"], **search_params)

                if tours_result["success"] and tours_result["count"] > 0:
                    tours_found = tours_result["tours"]
                    search_strategy = f"exact_match_{exact_match['type']}"
                    searched_location = exact_match
                    print(f"‚úÖ Found {len(tours_found)} tours for exact match: {exact_match['name']}")

            # Strategy 2: If exact match was a city but no tours found, try the parent country
            if not tours_found and location_result["exact_match"] and location_result["exact_match"]["type"] == "city":
                city = location_result["exact_match"]
                country_id = city.get("country_id")
                country_name = city.get("country")

                if country_id:
                    print(f"üîÑ No tours found for {city['name']}, trying parent country {country_name}")
                    tours_result = search_tours_for_location(country_id, **search_params)

                    if tours_result["success"] and tours_result["count"] > 0:
                        tours_found = tours_result["tours"]
                        search_strategy = "country_fallback_from_city"

                        # Find the country info from the results
                        for country in location_result["all_countries"]:
                            if country["id"] == country_id:
                                searched_location = country
                                break

                        print(f"‚úÖ Found {len(tours_found)} tours for parent country: {country_name}")

            # Strategy 3: If we matched a country but no direct tours, search all cities in that country
            if not tours_found and location_result["exact_match"] and location_result["exact_match"][
                "type"] == "country":
                country = location_result["exact_match"]
                all_country_tours = []
                cities_with_tours = []

                print(f"üîç Searching all cities in {country['name']}")
                for city in country.get("cities", []):
                    city_tours_result = search_tours_for_location(city["id"], **search_params)
                    if city_tours_result["success"] and city_tours_result["count"] > 0:
                        all_country_tours.extend(city_tours_result["tours"])
                        cities_with_tours.append(city["name"])

                if all_country_tours:
                    tours_found = all_country_tours
                    search_strategy = "cities_in_country"
                    searched_location = country
                    print(
                        f"‚úÖ Found {len(tours_found)} tours across {len(cities_with_tours)} cities in {country['name']}")

            # Strategy 4: If we found similar cities, try the first few matches
            if not tours_found and location_result["city_matches"]:
                print(f"üîç Trying similar city matches")
                for city in location_result["city_matches"][:3]:  # Try top 3 matches
                    city_tours_result = search_tours_for_location(city["id"], **search_params)
                    if city_tours_result["success"] and city_tours_result["count"] > 0:
                        tours_found = city_tours_result["tours"]
                        search_strategy = "similar_city"
                        searched_location = city
                        print(
                            f"‚úÖ Found {len(tours_found)} tours for similar city: {city['name']} in {city.get('country', '')}")
                        break

            # Strategy 5: If we have a country match, try its cities
            if not tours_found and location_result["country_match"]:
                country = location_result["country_match"]
                all_country_tours = []
                cities_with_tours = []

                print(f"üîç Trying cities in matched country {country['name']}")
                for city in country.get("cities", [])[:5]:  # Limit to first 5 cities
                    city_tours_result = search_tours_for_location(city["id"], **search_params)
                    if city_tours_result["success"] and city_tours_result["count"] > 0:
                        all_country_tours.extend(city_tours_result["tours"])
                        cities_with_tours.append(city["name"])

                if all_country_tours:
                    tours_found = all_country_tours
                    search_strategy = "country_match_cities"
                    searched_location = country
                    print(f"‚úÖ Found {len(tours_found)} tours in {country['name']}")

            # Apply additional filters if tours found
            if tours_found:
                filtered_tours = tours_found

                if budget_max:
                    original_count = len(filtered_tours)
                    filtered_tours = [t for t in filtered_tours
                                      if t.get("price") is not None and t.get("price", 0) <= budget_max]
                    print(f"üí∞ Budget filter: {original_count} -> {len(filtered_tours)} tours")

                if duration_days:
                    original_count = len(filtered_tours)
                    filtered_tours = [t for t in filtered_tours
                                      if t.get("days") is not None and abs(t.get("days", 0) - duration_days) <= 2]
                    print(f"üìÖ Duration filter: {original_count} -> {len(filtered_tours)} tours")

                # Build intelligent suggestions based on search strategy
                suggestions = _build_intelligent_suggestions(
                    search_strategy, searched_location, original_location, location_result, search_params
                )

                return {
                    "status": "success",
                    "count": len(filtered_tours),
                    "tours": filtered_tours[:10],
                    "search_strategy": search_strategy,
                    "searched_location": searched_location["name"] if searched_location else None,
                    "searched_location_type": searched_location["type"] if searched_location else None,
                    "original_query": destination_place,
                    "suggestions": suggestions,
                    "has_more": len(filtered_tours) > 10,
                    "message": _build_search_message(search_strategy, searched_location, len(filtered_tours),
                                                     destination_place, original_location)
                }
            else:
                # No tours found anywhere - provide intelligent suggestions
                suggestions = _build_no_tours_suggestions(location_result, destination_place)

                return {
                    "status": "no_tours_found",
                    "count": 0,
                    "tours": [],
                    "searched_for": destination_place,
                    "suggestions": suggestions,
                    "message": f"No tours found for '{destination_place}'. Here are some alternatives: {', '.join(suggestions[:3])}"
                }

        else:
            # No destination specified, search all
            response = requests.get(f"{TURTOPAR_API_BASE}/tours", params=search_params, timeout=15)
            if response.status_code == 200:
                data = response.json()
                if data.get("success"):
                    tours = data.get("data", [])
                    return {
                        "status": "success",
                        "count": len(tours),
                        "tours": tours[:10],
                        "message": f"Found {len(tours)} tours available"
                    }

        return {
            "status": "error",
            "message": "Failed to search tours",
            "tours": [],
            "count": 0
        }

    except Exception as e:
        print(f"üí• Search error: {str(e)}")
        return {
            "status": "error",
            "message": f"Search error: {str(e)}",
            "tours": [],
            "count": 0
        }


def _build_intelligent_suggestions(search_strategy: str, searched_location: Dict, original_location: Dict,
                                   location_result: Dict, search_params: Dict) -> List[str]:
    """Build intelligent suggestions based on the search strategy and results"""
    suggestions = []

    if search_strategy == "country_fallback_from_city":
        # Original search was for a city (e.g., Bali), but we found tours for the country (Indonesia)
        # Suggest other cities in the same country
        country = searched_location
        cities_with_tours = []

        for city in country.get("cities", [])[:8]:  # Check more cities for better suggestions
            if city["name"] != original_location["name"]:  # Don't suggest the original city
                city_tours_result = search_tours_for_location(city["id"], **search_params)
                if city_tours_result["success"] and city_tours_result["count"] > 0:
                    cities_with_tours.append(city["name"])

        suggestions = cities_with_tours[:5]

    elif search_strategy in ["cities_in_country", "country_match_cities"]:
        # We found tours across multiple cities in a country
        country = searched_location
        suggestions = [city["name"] for city in country.get("cities", [])[:5]]

    elif search_strategy == "similar_city":
        # We found a similar city, suggest other cities in the same country
        city = searched_location
        country_name = city.get("country")
        if country_name:
            # Find other cities in the same country
            for country in location_result.get("all_countries", []):
                if country["name"] == country_name:
                    suggestions = [c["name"] for c in country["cities"][:4] if c["name"] != city["name"]]
                    break

    return suggestions


def _build_no_tours_suggestions(location_result: Dict, original_query: str) -> List[str]:
    """Build suggestions when no tours are found"""
    suggestions = []

    if location_result["exact_match"] and location_result["exact_match"]["type"] == "city":
        # User searched for a specific city, suggest other cities in the same country
        city = location_result["exact_match"]
        country_name = city.get("country")

        if country_name:
            # Find other cities in the same country
            for country in location_result.get("all_countries", []):
                if country["name"] == country_name:
                    other_cities = [c["name"] for c in country["cities"][:5] if c["name"] != city["name"]]
                    suggestions.extend(other_cities)
                    break

        # If still no suggestions, add the country itself
        if not suggestions and country_name:
            suggestions.append(country_name)

    elif location_result["country_match"]:
        # User searched for a country, suggest popular cities in that country
        country = location_result["country_match"]
        suggestions = [city["name"] for city in country["cities"][:5]]

    elif location_result["city_matches"]:
        # User search matched similar cities, suggest them
        suggestions = [city["name"] for city in location_result["city_matches"][:4]]
        # Add their countries too
        for city in location_result["city_matches"][:2]:
            if city.get("country") and city["country"] not in suggestions:
                suggestions.append(city["country"])

    # If still no suggestions, add popular destinations
    if not suggestions:
        suggestions = ["Turkiya", "BAA", "Tailand", "Misr", "Gruziya", "Indoneziya"]

    return suggestions[:6]  # Limit to 6 suggestions


def _build_search_message(search_strategy: str, searched_location: Dict, tour_count: int,
                          original_query: str, original_location: Dict = None) -> str:
    """Build a descriptive message about the search results"""
    if not searched_location:
        return f"Found {tour_count} tours"

    location_name = searched_location["name"]

    if search_strategy == "exact_match_city":
        return f"Found {tour_count} tours to {location_name}"
    elif search_strategy == "exact_match_country":
        return f"Found {tour_count} tours to {location_name}"
    elif search_strategy == "country_fallback_from_city":
        original_name = original_location["name"] if original_location else original_query
        return f"No specific tours to {original_name}, but found {tour_count} tours to {location_name}. Check the suggestions for specific cities."
    elif search_strategy == "cities_in_country":
        return f"Found {tour_count} tours across various cities in {location_name}"
    elif search_strategy == "country_match_cities":
        return f"Found {tour_count} tours in {location_name} (matched from your search)"
    elif search_strategy == "similar_city":
        return f"Found {tour_count} tours to {location_name} (similar to '{original_query}')"
    else:
        return f"Found {tour_count} tours"

# Keep the other existing tools unchanged
@tool
def get_tour_details(tour_slug: str) -> Dict[str, Any]:
    """
    Get detailed information about a specific tour using its slug.
    """
    try:
        print(f"üîç Fetching detailed tour info for: {tour_slug}")

        response = requests.get(f"{TURTOPAR_API_BASE}/tours/view/{tour_slug}", timeout=15)

        if response.status_code == 200:
            data = response.json()

            if data.get("success"):
                tour_data = data.get("data", {})

                tour_info = {
                    "status": "success",
                    "tour_details": {
                        "id": tour_data.get("id"),
                        "name": tour_data.get("name"),
                        "description": tour_data.get("description"),
                        "price": tour_data.get("price"),
                        "currency": tour_data.get("currency", "USD"),
                        "duration": {
                            "days": tour_data.get("days"),
                            "nights": tour_data.get("nights")
                        },
                        "dates": {
                            "from": tour_data.get("from_date"),
                            "to": tour_data.get("to_date")
                        },
                        "is_hot": tour_data.get("is_hot", False),
                        "images": tour_data.get("images", []),
                        "locations": tour_data.get("locations", [])
                    },
                    "hotels": [],
                    "organization": tour_data.get("organization", {}),
                    "contact_info": {
                        "responsible_person": tour_data.get("responsible_user", {}),
                        "organization": tour_data.get("organization", {}),
                        "contact_phone": tour_data.get("contact_phone")
                    },
                    "features": tour_data.get("features", []),
                    "facilities": tour_data.get("facilities", []),
                    "schedules": tour_data.get("schedules", []),
                    "meta_data": tour_data.get("meta_data", {})
                }

                # Extract hotel information
                for location in tour_data.get("locations", []):
                    for hotel in location.get("hotels", []):
                        tour_info["hotels"].append({
                            "name": hotel.get("hotel_name"),
                            "stars": hotel.get("stars"),
                            "price": hotel.get("price"),
                            "currency": hotel.get("currency", "USD"),
                            "nights": hotel.get("nights"),
                            "image": hotel.get("image"),
                            "features": hotel.get("features", []),
                            "location": hotel.get("location_name")
                        })

                return tour_info

        return {
            "status": "error",
            "message": "Tour details not found",
            "tour_details": {}
        }

    except Exception as e:
        return {
            "status": "error",
            "message": f"Error fetching tour details: {str(e)}",
            "tour_details": {}
        }


@tool
def get_tour_recommendations(
        interests: List[str],
        budget_range: Optional[str] = None,
        travel_style: Optional[str] = None,
        season: Optional[str] = None,
        origin_city: Optional[str] = "Toshkent"
) -> Dict[str, Any]:
    """
    Get personalized tour recommendations based on customer interests and preferences.
    """
    # Interest to destination mapping
    interest_destinations = {
        "beach": ["Antaliya", "Dubai", "Sharm al-Shayx", "Pxuket", "Bali", "Male"],
        "luxury": ["Dubai", "Abu-Dabi", "Parij", "Maldiv orollari"],
        "culture": ["Istanbul", "Buxoro", "Samarqand", "Parij", "Anqara"],
        "adventure": ["Kappadokiya", "Trabzon", "Gruziya", "Vetnam", "Xitoy"],
        "family": ["Antaliya", "Dubai", "Istanbul", "Tailand", "BAA"],
        "shopping": ["Dubai", "Istanbul", "Bangkok", "Kuala-Lumpur"],
        "food": ["Istanbul", "Bangkok", "Vetnam", "Malayziya"],
        "history": ["Turkiya", "Misr", "Gruziya", "Uzbekiston"],
        "romance": ["Parij", "Maldiv orollari", "Istanbul", "Bali"],
        "nature": ["Kappadokiya", "Gruziya", "Vetnam", "Malayziya", "Indoneziya"],
        "religious": ["Saudiya Arabistoni", "Turkiya", "Misr"],
        "wellness": ["Tailand", "Bali", "Gruziya", "Turkiya"]
    }

    budget_ranges = {
        "budget": (0, 500),
        "mid-range": (500, 1000),
        "luxury": (1000, 5000)
    }

    try:
        # Find recommended destinations based on interests
        recommended_places = []
        for interest in interests:
            interest_lower = interest.lower()
            for key, places in interest_destinations.items():
                if key in interest_lower or interest_lower in key:
                    recommended_places.extend(places)

        # Remove duplicates and get unique recommendations
        unique_places = list(set(recommended_places))

        # Search for tours to recommended destinations
        all_recommended_tours = []

        for place in unique_places[:5]:  # Limit to top 5 destinations
            search_result = search_tours(
                origin_city=origin_city,
                destination_place=place,
                sort_by="price_asc"
            )

            if search_result.get("status") == "success":
                tours = search_result.get("tours", [])

                # Apply budget filter
                if budget_range and budget_range.lower() in budget_ranges:
                    min_price, max_price = budget_ranges[budget_range.lower()]
                    tours = [t for t in tours if min_price <= t.get("price", 0) <= max_price]

                all_recommended_tours.extend(tours)

        # Sort by price and remove duplicates
        unique_tours = {tour["id"]: tour for tour in all_recommended_tours}.values()
        sorted_tours = sorted(unique_tours, key=lambda x: x.get("price", 0))

        return {
            "status": "success",
            "recommendations": list(sorted_tours)[:8],
            "based_on": {
                "interests": interests,
                "budget_range": budget_range,
                "travel_style": travel_style,
                "season": season
            },
            "recommended_destinations": unique_places[:5],
            "message": f"Found {len(sorted_tours)} tours matching your interests: {', '.join(interests)}"
        }

    except Exception as e:
        return {
            "status": "error",
            "message": f"Recommendation error: {str(e)}",
            "recommendations": []
        }


@tool
def get_popular_destinations() -> Dict[str, Any]:
    """Get list of popular travel destinations with brief descriptions."""
    popular_destinations = {
        "Turkiya": {
            "cities": ["Istanbul", "Antaliya", "Kappadokiya", "Bodrum"],
            "highlights": ["Rich history", "Beautiful beaches", "Affordable luxury", "Amazing cuisine"],
            "best_for": ["Culture", "Beach", "Family", "History"],
            "season": "March-November"
        },
        "BAA": {
            "cities": ["Dubai", "Abu-Dabi", "Sharja"],
            "highlights": ["Modern luxury", "Shopping", "Desert safari", "World-class hotels"],
            "best_for": ["Luxury", "Shopping", "Modern architecture", "Adventure"],
            "season": "October-April"
        },
        "Tailand": {
            "cities": ["Pxuket", "Bangkok", "Pattaya"],
            "highlights": ["Tropical paradise", "Thai massage", "Street food", "Temples"],
            "best_for": ["Beach", "Wellness", "Food", "Adventure"],
            "season": "November-March"
        },
        "Misr": {
            "cities": ["Sharm al-Shayx", "Hurghada"],
            "highlights": ["Red Sea diving", "Ancient history", "Affordable beach resort"],
            "best_for": ["Beach", "Diving", "History", "Budget"],
            "season": "September-May"
        },
        "Gruziya": {
            "cities": ["Tbilisi", "Batumi"],
            "highlights": ["Wine country", "Mountain beauty", "Friendly people", "Great food"],
            "best_for": ["Culture", "Nature", "Food", "Adventure"],
            "season": "April-October"
        },
        "Maldiv orollari": {
            "cities": ["Male", "Bodufoludo"],
            "highlights": ["Overwater bungalows", "Crystal clear waters", "Luxury resorts"],
            "best_for": ["Romance", "Luxury", "Beach", "Honeymoon"],
            "season": "November-April"
        }
    }

    return {
        "status": "success",
        "destinations": popular_destinations,
        "message": "Here are our most popular destinations with their highlights"
    }


@tool
def format_tour_details(tour_data: Dict[str, Any]) -> str:
    """Format tour information for easy reading."""
    tour = tour_data

    details = f"""
üåü **{tour.get('name', 'Tour Package')}**
üìç **Destination:** {tour.get('locations', 'Multiple locations')}
üè¢ **Operator:** {tour.get('organization_name', 'Tour Company')}

üí∞ **Price:** ${tour.get('price', 0)} USD
‚è±Ô∏è **Duration:** {tour.get('days', 0)} days / {tour.get('nights', 0)} nights
üìÖ **Dates:** {tour.get('from_date', '')} - {tour.get('to_date', '')}
üÜî **Tour ID:** {tour.get('slug', 'N/A')}

üìù **Description:**
{tour.get('description', 'Full tour package with accommodation, transfers and guided tours.')}

‚ú® **Included Features:**"""

    features = tour.get('features', [])
    if features:
        for feature in features:
            details += f"\n‚Ä¢ {feature.get('name', 'Tour service')}"
    else:
        details += "\n‚Ä¢ Accommodation\n‚Ä¢ Airport transfers\n‚Ä¢ Tour guide\n‚Ä¢ Selected meals"

    details += f"\n\n**üìû For more details and booking, use the tour slug: {tour.get('slug', 'contact-agent')}**"

    return details